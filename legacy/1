import { BotManager } from '../../../../bot.ts';
import { Constants } from '../../../../struct/constants.ts';
import { InteractionHelper } from '../../../../util/helper/interaction.ts';
import { KvHelper } from '../../../../util/helper/kv.ts';
import { PermissionHelper } from '../../../../util/helper/permission.ts';
import { Initializable } from '../../../../util/structure/initializable.ts';
import { EmojiValidator } from '../../../../util/validate/emoji.ts';

export class ReactionInteractionHandlerSubForward extends Initializable {
  public override initialize(): Promise<void> | void {
    BotManager.event.add('interactionCreate', async (interaction) => {
      if (!InteractionHelper.isContextApplicationCommand('reaction', interaction)) return;
      const args = InteractionHelper.parseApplicationCommand<{
        forward?: {
          set?: {
            from: typeof BotManager.bot.transformers.$inferredTypes.channel;
            to: typeof BotManager.bot.transformers.$inferredTypes.channel;
            reaction: string;
            threshold: number;
            within?: number;
            resending?: number;
            message?: string;
          };
          remove?: {
            from: typeof BotManager.bot.transformers.$inferredTypes.channel;
            reaction: string;
          };
        };
      }>(interaction);
      if (args.forward === undefined) return;
      await interaction.defer();

      // Check Permissions
      const member = await BotManager.bot.cache.members.get(interaction.user.id, interaction.member?.guildId!);
      if (!await PermissionHelper.checkRolesForPermission(member!, member!.roles, ['MANAGE_MESSAGES'])) {
        return InteractionHelper.unauthorized(interaction);
      }

      // Forwarder Configuration
      if (args.forward?.set) {
        const reaction = args.forward.set.reaction;
        if (!EmojiValidator.check(reaction)) {
          await interaction.respond({
            embeds: InteractionHelper.makeErrorEmbed()
              .setDescription('Failed to validate the emoji.')
              .addField('Invalid', reaction),
          });
          return;
        }

        // ['reactToForwardMessage', args.forward.set.from.guildId!.toString(), args.forward.set.from.id!.toString(), reaction]
        await Constants.conf!.set(
          KvHelper.make({
            table: 'auto-forward',
            guildId: args.forward.set.from.guildId!.toString(),
            bucket: 'options',
            path: [args.forward.set.from.id!.toString(), 'reaction', reaction],
          }),
          {
            threshold: args.forward.set.threshold,
            to: {
              guildId: args.forward.set.to.guildId!.toString(),
              channelId: args.forward.set.to.id!.toString(),
            },
            within: args.forward.set.within ?? Infinity,
            resending: args.forward.set.resending ?? args.forward.set.within ?? 10080,
            message: args.forward.set.message,
          },
        );

        await interaction.respond({
          embeds: InteractionHelper.makeSuccessEmbed()
            .setDescription('Forwarding by reactions has been set for the specified channel.')
            .addField('From Channel', `<#${args.forward.set.from!.id}>`, true)
            .addField('To Channel', `<#${args.forward.set.to!.id}>`, true)
            .addField('\u200b', '\u200b', true)
            .addField('Reaction', `${args.forward.set.reaction}`, true)
            .addField('Threshold', `${args.forward.set.threshold} Reactions`, true),
        });
      }

      if (args.forward?.remove) {
        // Check Reaction
        const reaction = args.forward.remove.reaction;
        if (!EmojiValidator.check(reaction)) {
          await interaction.respond({
            embeds: InteractionHelper.makeErrorEmbed()
              .setDescription('Failed to validate the emoji.')
              .addField('Invalid', reaction),
          });
          return;
        }

        // Make Deletion
        const key = KvHelper.make({
          table: 'auto-react',
          guildId: args.forward.remove.from.guildId!.toString(),
          bucket: 'options',
          path: [args.forward.remove.from.id!.toString(), 'reaction', reaction],
        });
        const varg = Constants.conf!.list({ prefix: key });
        for await (const v of varg) {
          await Constants.conf!.delete(v.key);
        }
        await interaction.respond({
          embeds: InteractionHelper.makeSuccessEmbed()
            .setDescription('Forwarding by reactions has been removed from the specified channel.')
            .addField('Selected Channel', `<#${args.forward.remove.from!.id}>`)
            .addField('Reaction', `${args.forward.remove.reaction}`, true),
        });
      }
    });
  }
}
