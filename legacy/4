import { avatarUrl, ButtonStyles, type DiscordEmbed, EmbedsBuilder, MessageComponentTypes } from '@discordeno';
import { BotManager } from '../../../bot.ts';
import { Constants } from '../../../struct/constants.ts';
import { KvHelper } from '../../../util/helper/kv.ts';
import { Initializable } from '../../../util/structure/initializable.ts';
import type { ReactionForwardConfiguration } from '../type/reaction.d.ts';

export class ReactionReactionAddEvent extends Initializable {
  public override initialize(): Promise<void> | void {
    BotManager.event.add('reactionAdd', async (reaction) => {
      // Check for Properties
      if (reaction.guildId === undefined) return;
      if (reaction.emoji.name === undefined) return;

      // Check for Configuration
      const confKey = KvHelper.make({
        table: 'auto-forward',
        guildId: reaction.guildId.toString(),
        bucket: 'options',
        path: [reaction.channelId.toString(), 'reaction', reaction.emoji.name],
      });
      const conf = await Constants.conf!.get<ReactionForwardConfiguration>(confKey);
      if (conf.versionstamp === null) {
        return;
      }

      // Check Lock
      const lockKey = KvHelper.make({
        table: 'lock-state',
        guildId: reaction.guildId.toString(),
        bucket: 'auto-forward',
        path: [reaction.channelId.toString(), reaction.messageId.toString()],
      });
      const lock = await Constants.lock!.get<boolean>(lockKey);
      if (lock.versionstamp !== null) {
        return;
      }

      // Get Message
      const message = await BotManager.bot.helpers.getMessage(reaction.channelId, reaction.messageId);
      const reactionFromMessage = message.reactions?.filter((v) => v.emoji.name === reaction.emoji.name)[0];
      if (reactionFromMessage === undefined) return;

      // Check Age of Message
      if (message.timestamp < (Date.now() - (conf.value.within * 1000))) {
        return;
      }

      // Check Count
      const count = reactionFromMessage.count - (reactionFromMessage.me ? 1 : 0);
      if (count < conf.value.threshold) {
        return;
      }

      // Add Lock Key
      await Constants.lock!.set(lockKey, true, {
        expireIn: conf.value.resending * 1000,
      });

      // Parse Media Type(s)
      let type: 'text' | 'embed' = 'text';
      if ((message.embeds?.length ?? 0) !== 0) type = 'embed';

      // Dispatch
      switch (type) {
        case 'embed': {
          // Send with Text and Embed
          await BotManager.bot.helpers.sendMessage(BigInt(conf.value.to.channelId), {
            content: conf.value.message,
            embeds: new EmbedsBuilder(...message.embeds as DiscordEmbed[] ?? []),
            components: [
              {
                type: MessageComponentTypes.ActionRow,
                components: [
                  {
                    label: 'Original Message',
                    type: MessageComponentTypes.Button,
                    style: ButtonStyles.Link,
                    url: `https://discord.com/channels/${reaction.guildId.toString()}/${message.channelId.toString()}/${message.id.toString()}`,
                  },
                ],
              },
            ],
          });
          break;
        }
        default: {
          // Process Attachments
          const embeds = new EmbedsBuilder()
            .setAuthor(`${message.author.globalName ?? message.author.username}`, {
              icon_url: avatarUrl(message.author.id, '', {
                avatar: message.author.avatar,
              }),
            }).setDescription(message.content);
          if (message.attachments !== undefined && message.attachments.length > 0) {
            for (let i = 0; i < (message.attachments?.length ?? 0); i++) {
              const attachment = message.attachments[i];
              if (attachment.contentType?.startsWith('image')) {
                if (i !== 0) embeds.newEmbed();
                embeds.setUrl(attachment.url)
                  .setImage(attachment.url);
              }
            }
          }

          // Send with Attachments
          await BotManager.bot.helpers.sendMessage(BigInt(conf.value.to.channelId), {
            content: conf.value.message,
            embeds,
            components: [
              {
                type: MessageComponentTypes.ActionRow,
                components: [
                  {
                    label: 'Original Message',
                    type: MessageComponentTypes.Button,
                    style: ButtonStyles.Link,
                    url: `https://discord.com/channels/${reaction.guildId.toString()}/${message.channelId.toString()}/${message.id.toString()}`,
                  },
                ],
              },
            ],
          });
          break;
        }
      }
    });
  }
}
